// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cncstatebuf.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "cncstatebuf.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace CncRemote {

void protobuf_ShutdownFile_cncstatebuf_2eproto() {
  Axes_default_instance_.Shutdown();
  BoolAxes_default_instance_.Shutdown();
  StateBuf_default_instance_.Shutdown();
  CmdBuf_default_instance_.Shutdown();
}

void protobuf_InitDefaults_cncstatebuf_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::GetEmptyString();
  Axes_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  BoolAxes_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  StateBuf_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  CmdBuf_default_instance_.DefaultConstruct();
  Axes_default_instance_.get_mutable()->InitAsDefaultInstance();
  BoolAxes_default_instance_.get_mutable()->InitAsDefaultInstance();
  StateBuf_default_instance_.get_mutable()->InitAsDefaultInstance();
  CmdBuf_default_instance_.get_mutable()->InitAsDefaultInstance();
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_InitDefaults_cncstatebuf_2eproto_once_);
void protobuf_InitDefaults_cncstatebuf_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_InitDefaults_cncstatebuf_2eproto_once_,
                 &protobuf_InitDefaults_cncstatebuf_2eproto_impl);
}
void protobuf_AddDesc_cncstatebuf_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  protobuf_InitDefaults_cncstatebuf_2eproto();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_cncstatebuf_2eproto);
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_cncstatebuf_2eproto_once_);
void protobuf_AddDesc_cncstatebuf_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_cncstatebuf_2eproto_once_,
                 &protobuf_AddDesc_cncstatebuf_2eproto_impl);
}
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_cncstatebuf_2eproto {
  StaticDescriptorInitializer_cncstatebuf_2eproto() {
    protobuf_AddDesc_cncstatebuf_2eproto();
  }
} static_descriptor_initializer_cncstatebuf_2eproto_;
#endif  // GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
bool SPINDLE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD GOOGLE_ATTRIBUTE_NORETURN;
static void MergeFromFail(int line) {
  ::google::protobuf::internal::MergeFromFail(__FILE__, line);
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForAxes(
    Axes* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Axes::kXFieldNumber;
const int Axes::kYFieldNumber;
const int Axes::kZFieldNumber;
const int Axes::kAFieldNumber;
const int Axes::kBFieldNumber;
const int Axes::kCFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Axes::Axes()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_cncstatebuf_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CncRemote.Axes)
}

void Axes::InitAsDefaultInstance() {
}

Axes::Axes(const Axes& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CncRemote.Axes)
}

void Axes::SharedCtor() {
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&x_, 0, reinterpret_cast<char*>(&c_) -
    reinterpret_cast<char*>(&x_) + sizeof(c_));
}

Axes::~Axes() {
  // @@protoc_insertion_point(destructor:CncRemote.Axes)
  SharedDtor();
}

void Axes::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Axes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Axes& Axes::default_instance() {
  protobuf_InitDefaults_cncstatebuf_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<Axes> Axes_default_instance_;

Axes* Axes::New(::google::protobuf::Arena* arena) const {
  Axes* n = new Axes;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Axes::Clear() {
// @@protoc_insertion_point(message_clear_start:CncRemote.Axes)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Axes, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Axes*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, c_);

#undef ZR_HELPER_
#undef ZR_

  _has_bits_.Clear();
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Axes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForAxes, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:CncRemote.Axes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double x = 1;
      case 1: {
        if (tag == 9) {
          set_has_x();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_y;
        break;
      }

      // optional double y = 2;
      case 2: {
        if (tag == 17) {
         parse_y:
          set_has_y();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_z;
        break;
      }

      // optional double z = 3;
      case 3: {
        if (tag == 25) {
         parse_z:
          set_has_z();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_a;
        break;
      }

      // optional double a = 4;
      case 4: {
        if (tag == 33) {
         parse_a:
          set_has_a();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &a_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_b;
        break;
      }

      // optional double b = 5;
      case 5: {
        if (tag == 41) {
         parse_b:
          set_has_b();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &b_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_c;
        break;
      }

      // optional double c = 6;
      case 6: {
        if (tag == 49) {
         parse_c:
          set_has_c();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &c_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CncRemote.Axes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CncRemote.Axes)
  return false;
#undef DO_
}

void Axes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CncRemote.Axes)
  // optional double x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x(), output);
  }

  // optional double y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y(), output);
  }

  // optional double z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->z(), output);
  }

  // optional double a = 4;
  if (has_a()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->a(), output);
  }

  // optional double b = 5;
  if (has_b()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->b(), output);
  }

  // optional double c = 6;
  if (has_c()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->c(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:CncRemote.Axes)
}

size_t Axes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CncRemote.Axes)
  size_t total_size = 0;

  if (_has_bits_[0 / 32] & 63u) {
    // optional double x = 1;
    if (has_x()) {
      total_size += 1 + 8;
    }

    // optional double y = 2;
    if (has_y()) {
      total_size += 1 + 8;
    }

    // optional double z = 3;
    if (has_z()) {
      total_size += 1 + 8;
    }

    // optional double a = 4;
    if (has_a()) {
      total_size += 1 + 8;
    }

    // optional double b = 5;
    if (has_b()) {
      total_size += 1 + 8;
    }

    // optional double c = 6;
    if (has_c()) {
      total_size += 1 + 8;
    }

  }
  total_size += unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Axes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Axes*>(&from));
}

void Axes::MergeFrom(const Axes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CncRemote.Axes)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void Axes::UnsafeMergeFrom(const Axes& from) {
  GOOGLE_DCHECK(&from != this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_a()) {
      set_a(from.a());
    }
    if (from.has_b()) {
      set_b(from.b());
    }
    if (from.has_c()) {
      set_c(from.c());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Axes::CopyFrom(const Axes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CncRemote.Axes)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool Axes::IsInitialized() const {

  return true;
}

void Axes::Swap(Axes* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Axes::InternalSwap(Axes* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(a_, other->a_);
  std::swap(b_, other->b_);
  std::swap(c_, other->c_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Axes::GetTypeName() const {
  return "CncRemote.Axes";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Axes

// optional double x = 1;
bool Axes::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Axes::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void Axes::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void Axes::clear_x() {
  x_ = 0;
  clear_has_x();
}
double Axes::x() const {
  // @@protoc_insertion_point(field_get:CncRemote.Axes.x)
  return x_;
}
void Axes::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.Axes.x)
}

// optional double y = 2;
bool Axes::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Axes::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void Axes::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void Axes::clear_y() {
  y_ = 0;
  clear_has_y();
}
double Axes::y() const {
  // @@protoc_insertion_point(field_get:CncRemote.Axes.y)
  return y_;
}
void Axes::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.Axes.y)
}

// optional double z = 3;
bool Axes::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Axes::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void Axes::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void Axes::clear_z() {
  z_ = 0;
  clear_has_z();
}
double Axes::z() const {
  // @@protoc_insertion_point(field_get:CncRemote.Axes.z)
  return z_;
}
void Axes::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.Axes.z)
}

// optional double a = 4;
bool Axes::has_a() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Axes::set_has_a() {
  _has_bits_[0] |= 0x00000008u;
}
void Axes::clear_has_a() {
  _has_bits_[0] &= ~0x00000008u;
}
void Axes::clear_a() {
  a_ = 0;
  clear_has_a();
}
double Axes::a() const {
  // @@protoc_insertion_point(field_get:CncRemote.Axes.a)
  return a_;
}
void Axes::set_a(double value) {
  set_has_a();
  a_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.Axes.a)
}

// optional double b = 5;
bool Axes::has_b() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Axes::set_has_b() {
  _has_bits_[0] |= 0x00000010u;
}
void Axes::clear_has_b() {
  _has_bits_[0] &= ~0x00000010u;
}
void Axes::clear_b() {
  b_ = 0;
  clear_has_b();
}
double Axes::b() const {
  // @@protoc_insertion_point(field_get:CncRemote.Axes.b)
  return b_;
}
void Axes::set_b(double value) {
  set_has_b();
  b_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.Axes.b)
}

// optional double c = 6;
bool Axes::has_c() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Axes::set_has_c() {
  _has_bits_[0] |= 0x00000020u;
}
void Axes::clear_has_c() {
  _has_bits_[0] &= ~0x00000020u;
}
void Axes::clear_c() {
  c_ = 0;
  clear_has_c();
}
double Axes::c() const {
  // @@protoc_insertion_point(field_get:CncRemote.Axes.c)
  return c_;
}
void Axes::set_c(double value) {
  set_has_c();
  c_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.Axes.c)
}

inline const Axes* Axes::internal_default_instance() {
  return &Axes_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForBoolAxes(
    BoolAxes* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BoolAxes::kXFieldNumber;
const int BoolAxes::kYFieldNumber;
const int BoolAxes::kZFieldNumber;
const int BoolAxes::kAFieldNumber;
const int BoolAxes::kBFieldNumber;
const int BoolAxes::kCFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BoolAxes::BoolAxes()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_cncstatebuf_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CncRemote.BoolAxes)
}

void BoolAxes::InitAsDefaultInstance() {
}

BoolAxes::BoolAxes(const BoolAxes& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CncRemote.BoolAxes)
}

void BoolAxes::SharedCtor() {
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&x_, 0, reinterpret_cast<char*>(&c_) -
    reinterpret_cast<char*>(&x_) + sizeof(c_));
}

BoolAxes::~BoolAxes() {
  // @@protoc_insertion_point(destructor:CncRemote.BoolAxes)
  SharedDtor();
}

void BoolAxes::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void BoolAxes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BoolAxes& BoolAxes::default_instance() {
  protobuf_InitDefaults_cncstatebuf_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<BoolAxes> BoolAxes_default_instance_;

BoolAxes* BoolAxes::New(::google::protobuf::Arena* arena) const {
  BoolAxes* n = new BoolAxes;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BoolAxes::Clear() {
// @@protoc_insertion_point(message_clear_start:CncRemote.BoolAxes)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(BoolAxes, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<BoolAxes*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, c_);

#undef ZR_HELPER_
#undef ZR_

  _has_bits_.Clear();
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool BoolAxes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForBoolAxes, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:CncRemote.BoolAxes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool x = 1;
      case 1: {
        if (tag == 8) {
          set_has_x();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // optional bool y = 2;
      case 2: {
        if (tag == 16) {
         parse_y:
          set_has_y();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_z;
        break;
      }

      // optional bool z = 3;
      case 3: {
        if (tag == 24) {
         parse_z:
          set_has_z();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_a;
        break;
      }

      // optional bool a = 4;
      case 4: {
        if (tag == 32) {
         parse_a:
          set_has_a();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &a_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_b;
        break;
      }

      // optional bool b = 5;
      case 5: {
        if (tag == 40) {
         parse_b:
          set_has_b();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &b_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_c;
        break;
      }

      // optional bool c = 6;
      case 6: {
        if (tag == 48) {
         parse_c:
          set_has_c();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &c_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CncRemote.BoolAxes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CncRemote.BoolAxes)
  return false;
#undef DO_
}

void BoolAxes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CncRemote.BoolAxes)
  // optional bool x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->x(), output);
  }

  // optional bool y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->y(), output);
  }

  // optional bool z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->z(), output);
  }

  // optional bool a = 4;
  if (has_a()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->a(), output);
  }

  // optional bool b = 5;
  if (has_b()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->b(), output);
  }

  // optional bool c = 6;
  if (has_c()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->c(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:CncRemote.BoolAxes)
}

size_t BoolAxes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CncRemote.BoolAxes)
  size_t total_size = 0;

  if (_has_bits_[0 / 32] & 63u) {
    // optional bool x = 1;
    if (has_x()) {
      total_size += 1 + 1;
    }

    // optional bool y = 2;
    if (has_y()) {
      total_size += 1 + 1;
    }

    // optional bool z = 3;
    if (has_z()) {
      total_size += 1 + 1;
    }

    // optional bool a = 4;
    if (has_a()) {
      total_size += 1 + 1;
    }

    // optional bool b = 5;
    if (has_b()) {
      total_size += 1 + 1;
    }

    // optional bool c = 6;
    if (has_c()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BoolAxes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BoolAxes*>(&from));
}

void BoolAxes::MergeFrom(const BoolAxes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CncRemote.BoolAxes)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void BoolAxes::UnsafeMergeFrom(const BoolAxes& from) {
  GOOGLE_DCHECK(&from != this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_a()) {
      set_a(from.a());
    }
    if (from.has_b()) {
      set_b(from.b());
    }
    if (from.has_c()) {
      set_c(from.c());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void BoolAxes::CopyFrom(const BoolAxes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CncRemote.BoolAxes)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool BoolAxes::IsInitialized() const {

  return true;
}

void BoolAxes::Swap(BoolAxes* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BoolAxes::InternalSwap(BoolAxes* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(a_, other->a_);
  std::swap(b_, other->b_);
  std::swap(c_, other->c_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string BoolAxes::GetTypeName() const {
  return "CncRemote.BoolAxes";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BoolAxes

// optional bool x = 1;
bool BoolAxes::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BoolAxes::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void BoolAxes::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void BoolAxes::clear_x() {
  x_ = false;
  clear_has_x();
}
bool BoolAxes::x() const {
  // @@protoc_insertion_point(field_get:CncRemote.BoolAxes.x)
  return x_;
}
void BoolAxes::set_x(bool value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.BoolAxes.x)
}

// optional bool y = 2;
bool BoolAxes::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void BoolAxes::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void BoolAxes::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void BoolAxes::clear_y() {
  y_ = false;
  clear_has_y();
}
bool BoolAxes::y() const {
  // @@protoc_insertion_point(field_get:CncRemote.BoolAxes.y)
  return y_;
}
void BoolAxes::set_y(bool value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.BoolAxes.y)
}

// optional bool z = 3;
bool BoolAxes::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void BoolAxes::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void BoolAxes::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void BoolAxes::clear_z() {
  z_ = false;
  clear_has_z();
}
bool BoolAxes::z() const {
  // @@protoc_insertion_point(field_get:CncRemote.BoolAxes.z)
  return z_;
}
void BoolAxes::set_z(bool value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.BoolAxes.z)
}

// optional bool a = 4;
bool BoolAxes::has_a() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void BoolAxes::set_has_a() {
  _has_bits_[0] |= 0x00000008u;
}
void BoolAxes::clear_has_a() {
  _has_bits_[0] &= ~0x00000008u;
}
void BoolAxes::clear_a() {
  a_ = false;
  clear_has_a();
}
bool BoolAxes::a() const {
  // @@protoc_insertion_point(field_get:CncRemote.BoolAxes.a)
  return a_;
}
void BoolAxes::set_a(bool value) {
  set_has_a();
  a_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.BoolAxes.a)
}

// optional bool b = 5;
bool BoolAxes::has_b() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void BoolAxes::set_has_b() {
  _has_bits_[0] |= 0x00000010u;
}
void BoolAxes::clear_has_b() {
  _has_bits_[0] &= ~0x00000010u;
}
void BoolAxes::clear_b() {
  b_ = false;
  clear_has_b();
}
bool BoolAxes::b() const {
  // @@protoc_insertion_point(field_get:CncRemote.BoolAxes.b)
  return b_;
}
void BoolAxes::set_b(bool value) {
  set_has_b();
  b_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.BoolAxes.b)
}

// optional bool c = 6;
bool BoolAxes::has_c() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void BoolAxes::set_has_c() {
  _has_bits_[0] |= 0x00000020u;
}
void BoolAxes::clear_has_c() {
  _has_bits_[0] &= ~0x00000020u;
}
void BoolAxes::clear_c() {
  c_ = false;
  clear_has_c();
}
bool BoolAxes::c() const {
  // @@protoc_insertion_point(field_get:CncRemote.BoolAxes.c)
  return c_;
}
void BoolAxes::set_c(bool value) {
  set_has_c();
  c_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.BoolAxes.c)
}

inline const BoolAxes* BoolAxes::internal_default_instance() {
  return &BoolAxes_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForStateBuf(
    StateBuf* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StateBuf::kAbsPosFieldNumber;
const int StateBuf::kOffsetWorkFieldNumber;
const int StateBuf::kOffsetFixtureFieldNumber;
const int StateBuf::kFeedOverrideFieldNumber;
const int StateBuf::kControlOnFieldNumber;
const int StateBuf::kMachineConnectedFieldNumber;
const int StateBuf::kPausedFieldNumber;
const int StateBuf::kOptionalStopFieldNumber;
const int StateBuf::kBlockDeleteFieldNumber;
const int StateBuf::kBusyFieldNumber;
const int StateBuf::kCurrentLineFieldNumber;
const int StateBuf::kSingleStepFieldNumber;
const int StateBuf::kSpindleSpeedFieldNumber;
const int StateBuf::kSpindleStateFieldNumber;
const int StateBuf::kMistFieldNumber;
const int StateBuf::kFloodFieldNumber;
const int StateBuf::kHomedFieldNumber;
const int StateBuf::kAxisLinearFieldNumber;
const int StateBuf::kErrorMsgFieldNumber;
const int StateBuf::kDisplayMsgFieldNumber;
const int StateBuf::kMaxFeedLinFieldNumber;
const int StateBuf::kMaxFeedAngFieldNumber;
const int StateBuf::kGcodeUnitsFieldNumber;
const int StateBuf::kSpindleOverrideFieldNumber;
const int StateBuf::kRapidOverrideFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StateBuf::StateBuf()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_cncstatebuf_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CncRemote.StateBuf)
}

void StateBuf::InitAsDefaultInstance() {
  abs_pos_ = const_cast< ::CncRemote::Axes*>(
      ::CncRemote::Axes::internal_default_instance());
  offset_work_ = const_cast< ::CncRemote::Axes*>(
      ::CncRemote::Axes::internal_default_instance());
  offset_fixture_ = const_cast< ::CncRemote::Axes*>(
      ::CncRemote::Axes::internal_default_instance());
  homed_ = const_cast< ::CncRemote::BoolAxes*>(
      ::CncRemote::BoolAxes::internal_default_instance());
  axis_linear_ = const_cast< ::CncRemote::BoolAxes*>(
      ::CncRemote::BoolAxes::internal_default_instance());
}

StateBuf::StateBuf(const StateBuf& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CncRemote.StateBuf)
}

void StateBuf::SharedCtor() {
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  error_msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  display_msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  abs_pos_ = NULL;
  offset_work_ = NULL;
  offset_fixture_ = NULL;
  homed_ = NULL;
  axis_linear_ = NULL;
  ::memset(&feed_override_, 0, reinterpret_cast<char*>(&flood_) -
    reinterpret_cast<char*>(&feed_override_) + sizeof(flood_));
}

StateBuf::~StateBuf() {
  // @@protoc_insertion_point(destructor:CncRemote.StateBuf)
  SharedDtor();
}

void StateBuf::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  error_msg_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  display_msg_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != &StateBuf_default_instance_.get()) {
    delete abs_pos_;
    delete offset_work_;
    delete offset_fixture_;
    delete homed_;
    delete axis_linear_;
  }
}

void StateBuf::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StateBuf& StateBuf::default_instance() {
  protobuf_InitDefaults_cncstatebuf_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<StateBuf> StateBuf_default_instance_;

StateBuf* StateBuf::New(::google::protobuf::Arena* arena) const {
  StateBuf* n = new StateBuf;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StateBuf::Clear() {
// @@protoc_insertion_point(message_clear_start:CncRemote.StateBuf)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(StateBuf, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<StateBuf*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(feed_override_, optional_stop_);
    if (has_abs_pos()) {
      if (abs_pos_ != NULL) abs_pos_->::CncRemote::Axes::Clear();
    }
    if (has_offset_work()) {
      if (offset_work_ != NULL) offset_work_->::CncRemote::Axes::Clear();
    }
    if (has_offset_fixture()) {
      if (offset_fixture_ != NULL) offset_fixture_->::CncRemote::Axes::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 65280u) {
    ZR_(current_line_, spindle_speed_);
    flood_ = false;
  }
  if (_has_bits_[16 / 32] & 16711680u) {
    ZR_(max_feed_lin_, spindle_override_);
    if (has_homed()) {
      if (homed_ != NULL) homed_->::CncRemote::BoolAxes::Clear();
    }
    if (has_axis_linear()) {
      if (axis_linear_ != NULL) axis_linear_->::CncRemote::BoolAxes::Clear();
    }
    if (has_error_msg()) {
      error_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_display_msg()) {
      display_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  rapid_override_ = 0;

#undef ZR_HELPER_
#undef ZR_

  _has_bits_.Clear();
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool StateBuf::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForStateBuf, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:CncRemote.StateBuf)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .CncRemote.Axes abs_pos = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_abs_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_offset_work;
        break;
      }

      // optional .CncRemote.Axes offset_work = 3;
      case 3: {
        if (tag == 26) {
         parse_offset_work:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_offset_work()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_offset_fixture;
        break;
      }

      // optional .CncRemote.Axes offset_fixture = 4;
      case 4: {
        if (tag == 34) {
         parse_offset_fixture:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_offset_fixture()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_feed_override;
        break;
      }

      // optional double feed_override = 6;
      case 6: {
        if (tag == 49) {
         parse_feed_override:
          set_has_feed_override();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &feed_override_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_control_on;
        break;
      }

      // optional bool control_on = 7;
      case 7: {
        if (tag == 56) {
         parse_control_on:
          set_has_control_on();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &control_on_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_machine_connected;
        break;
      }

      // optional bool machine_connected = 8;
      case 8: {
        if (tag == 64) {
         parse_machine_connected:
          set_has_machine_connected();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &machine_connected_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_paused;
        break;
      }

      // optional bool paused = 9;
      case 9: {
        if (tag == 72) {
         parse_paused:
          set_has_paused();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &paused_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_optional_stop;
        break;
      }

      // optional bool optional_stop = 10;
      case 10: {
        if (tag == 80) {
         parse_optional_stop:
          set_has_optional_stop();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &optional_stop_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_block_delete;
        break;
      }

      // optional bool block_delete = 11;
      case 11: {
        if (tag == 88) {
         parse_block_delete:
          set_has_block_delete();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &block_delete_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_busy;
        break;
      }

      // optional bool busy = 12;
      case 12: {
        if (tag == 96) {
         parse_busy:
          set_has_busy();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &busy_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_current_line;
        break;
      }

      // optional int32 current_line = 13;
      case 13: {
        if (tag == 104) {
         parse_current_line:
          set_has_current_line();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &current_line_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_single_step;
        break;
      }

      // optional bool single_step = 14;
      case 14: {
        if (tag == 112) {
         parse_single_step:
          set_has_single_step();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &single_step_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(121)) goto parse_spindle_speed;
        break;
      }

      // optional double spindle_speed = 15;
      case 15: {
        if (tag == 121) {
         parse_spindle_speed:
          set_has_spindle_speed();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &spindle_speed_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_spindle_state;
        break;
      }

      // optional uint32 spindle_state = 16;
      case 16: {
        if (tag == 128) {
         parse_spindle_state:
          set_has_spindle_state();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &spindle_state_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_mist;
        break;
      }

      // optional bool mist = 17;
      case 17: {
        if (tag == 136) {
         parse_mist:
          set_has_mist();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &mist_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_flood;
        break;
      }

      // optional bool flood = 18;
      case 18: {
        if (tag == 144) {
         parse_flood:
          set_has_flood();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flood_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_homed;
        break;
      }

      // optional .CncRemote.BoolAxes homed = 19;
      case 19: {
        if (tag == 154) {
         parse_homed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_homed()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_axis_linear;
        break;
      }

      // optional .CncRemote.BoolAxes axis_linear = 20;
      case 20: {
        if (tag == 162) {
         parse_axis_linear:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_axis_linear()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_error_msg;
        break;
      }

      // optional string error_msg = 21;
      case 21: {
        if (tag == 170) {
         parse_error_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_error_msg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(178)) goto parse_display_msg;
        break;
      }

      // optional string display_msg = 22;
      case 22: {
        if (tag == 178) {
         parse_display_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_display_msg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(185)) goto parse_max_feed_lin;
        break;
      }

      // optional double max_feed_lin = 23;
      case 23: {
        if (tag == 185) {
         parse_max_feed_lin:
          set_has_max_feed_lin();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_feed_lin_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(193)) goto parse_max_feed_ang;
        break;
      }

      // optional double max_feed_ang = 24;
      case 24: {
        if (tag == 193) {
         parse_max_feed_ang:
          set_has_max_feed_ang();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &max_feed_ang_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(201)) goto parse_gcode_units;
        break;
      }

      // optional double gcode_units = 25;
      case 25: {
        if (tag == 201) {
         parse_gcode_units:
          set_has_gcode_units();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &gcode_units_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(209)) goto parse_spindle_override;
        break;
      }

      // optional double spindle_override = 26;
      case 26: {
        if (tag == 209) {
         parse_spindle_override:
          set_has_spindle_override();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &spindle_override_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(217)) goto parse_rapid_override;
        break;
      }

      // optional double rapid_override = 27;
      case 27: {
        if (tag == 217) {
         parse_rapid_override:
          set_has_rapid_override();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &rapid_override_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CncRemote.StateBuf)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CncRemote.StateBuf)
  return false;
#undef DO_
}

void StateBuf::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CncRemote.StateBuf)
  // optional .CncRemote.Axes abs_pos = 2;
  if (has_abs_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->abs_pos_, output);
  }

  // optional .CncRemote.Axes offset_work = 3;
  if (has_offset_work()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->offset_work_, output);
  }

  // optional .CncRemote.Axes offset_fixture = 4;
  if (has_offset_fixture()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->offset_fixture_, output);
  }

  // optional double feed_override = 6;
  if (has_feed_override()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->feed_override(), output);
  }

  // optional bool control_on = 7;
  if (has_control_on()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->control_on(), output);
  }

  // optional bool machine_connected = 8;
  if (has_machine_connected()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->machine_connected(), output);
  }

  // optional bool paused = 9;
  if (has_paused()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->paused(), output);
  }

  // optional bool optional_stop = 10;
  if (has_optional_stop()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->optional_stop(), output);
  }

  // optional bool block_delete = 11;
  if (has_block_delete()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->block_delete(), output);
  }

  // optional bool busy = 12;
  if (has_busy()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->busy(), output);
  }

  // optional int32 current_line = 13;
  if (has_current_line()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->current_line(), output);
  }

  // optional bool single_step = 14;
  if (has_single_step()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->single_step(), output);
  }

  // optional double spindle_speed = 15;
  if (has_spindle_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(15, this->spindle_speed(), output);
  }

  // optional uint32 spindle_state = 16;
  if (has_spindle_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(16, this->spindle_state(), output);
  }

  // optional bool mist = 17;
  if (has_mist()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(17, this->mist(), output);
  }

  // optional bool flood = 18;
  if (has_flood()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(18, this->flood(), output);
  }

  // optional .CncRemote.BoolAxes homed = 19;
  if (has_homed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      19, *this->homed_, output);
  }

  // optional .CncRemote.BoolAxes axis_linear = 20;
  if (has_axis_linear()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      20, *this->axis_linear_, output);
  }

  // optional string error_msg = 21;
  if (has_error_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      21, this->error_msg(), output);
  }

  // optional string display_msg = 22;
  if (has_display_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      22, this->display_msg(), output);
  }

  // optional double max_feed_lin = 23;
  if (has_max_feed_lin()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(23, this->max_feed_lin(), output);
  }

  // optional double max_feed_ang = 24;
  if (has_max_feed_ang()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(24, this->max_feed_ang(), output);
  }

  // optional double gcode_units = 25;
  if (has_gcode_units()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(25, this->gcode_units(), output);
  }

  // optional double spindle_override = 26;
  if (has_spindle_override()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(26, this->spindle_override(), output);
  }

  // optional double rapid_override = 27;
  if (has_rapid_override()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(27, this->rapid_override(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:CncRemote.StateBuf)
}

size_t StateBuf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CncRemote.StateBuf)
  size_t total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional .CncRemote.Axes abs_pos = 2;
    if (has_abs_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->abs_pos_);
    }

    // optional .CncRemote.Axes offset_work = 3;
    if (has_offset_work()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->offset_work_);
    }

    // optional .CncRemote.Axes offset_fixture = 4;
    if (has_offset_fixture()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->offset_fixture_);
    }

    // optional double feed_override = 6;
    if (has_feed_override()) {
      total_size += 1 + 8;
    }

    // optional bool control_on = 7;
    if (has_control_on()) {
      total_size += 1 + 1;
    }

    // optional bool machine_connected = 8;
    if (has_machine_connected()) {
      total_size += 1 + 1;
    }

    // optional bool paused = 9;
    if (has_paused()) {
      total_size += 1 + 1;
    }

    // optional bool optional_stop = 10;
    if (has_optional_stop()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional bool block_delete = 11;
    if (has_block_delete()) {
      total_size += 1 + 1;
    }

    // optional bool busy = 12;
    if (has_busy()) {
      total_size += 1 + 1;
    }

    // optional int32 current_line = 13;
    if (has_current_line()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->current_line());
    }

    // optional bool single_step = 14;
    if (has_single_step()) {
      total_size += 1 + 1;
    }

    // optional double spindle_speed = 15;
    if (has_spindle_speed()) {
      total_size += 1 + 8;
    }

    // optional uint32 spindle_state = 16;
    if (has_spindle_state()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->spindle_state());
    }

    // optional bool mist = 17;
    if (has_mist()) {
      total_size += 2 + 1;
    }

    // optional bool flood = 18;
    if (has_flood()) {
      total_size += 2 + 1;
    }

  }
  if (_has_bits_[16 / 32] & 16711680u) {
    // optional .CncRemote.BoolAxes homed = 19;
    if (has_homed()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->homed_);
    }

    // optional .CncRemote.BoolAxes axis_linear = 20;
    if (has_axis_linear()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->axis_linear_);
    }

    // optional string error_msg = 21;
    if (has_error_msg()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->error_msg());
    }

    // optional string display_msg = 22;
    if (has_display_msg()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->display_msg());
    }

    // optional double max_feed_lin = 23;
    if (has_max_feed_lin()) {
      total_size += 2 + 8;
    }

    // optional double max_feed_ang = 24;
    if (has_max_feed_ang()) {
      total_size += 2 + 8;
    }

    // optional double gcode_units = 25;
    if (has_gcode_units()) {
      total_size += 2 + 8;
    }

    // optional double spindle_override = 26;
    if (has_spindle_override()) {
      total_size += 2 + 8;
    }

  }
  // optional double rapid_override = 27;
  if (has_rapid_override()) {
    total_size += 2 + 8;
  }

  total_size += unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StateBuf::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StateBuf*>(&from));
}

void StateBuf::MergeFrom(const StateBuf& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CncRemote.StateBuf)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void StateBuf::UnsafeMergeFrom(const StateBuf& from) {
  GOOGLE_DCHECK(&from != this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_abs_pos()) {
      mutable_abs_pos()->::CncRemote::Axes::MergeFrom(from.abs_pos());
    }
    if (from.has_offset_work()) {
      mutable_offset_work()->::CncRemote::Axes::MergeFrom(from.offset_work());
    }
    if (from.has_offset_fixture()) {
      mutable_offset_fixture()->::CncRemote::Axes::MergeFrom(from.offset_fixture());
    }
    if (from.has_feed_override()) {
      set_feed_override(from.feed_override());
    }
    if (from.has_control_on()) {
      set_control_on(from.control_on());
    }
    if (from.has_machine_connected()) {
      set_machine_connected(from.machine_connected());
    }
    if (from.has_paused()) {
      set_paused(from.paused());
    }
    if (from.has_optional_stop()) {
      set_optional_stop(from.optional_stop());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_block_delete()) {
      set_block_delete(from.block_delete());
    }
    if (from.has_busy()) {
      set_busy(from.busy());
    }
    if (from.has_current_line()) {
      set_current_line(from.current_line());
    }
    if (from.has_single_step()) {
      set_single_step(from.single_step());
    }
    if (from.has_spindle_speed()) {
      set_spindle_speed(from.spindle_speed());
    }
    if (from.has_spindle_state()) {
      set_spindle_state(from.spindle_state());
    }
    if (from.has_mist()) {
      set_mist(from.mist());
    }
    if (from.has_flood()) {
      set_flood(from.flood());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_homed()) {
      mutable_homed()->::CncRemote::BoolAxes::MergeFrom(from.homed());
    }
    if (from.has_axis_linear()) {
      mutable_axis_linear()->::CncRemote::BoolAxes::MergeFrom(from.axis_linear());
    }
    if (from.has_error_msg()) {
      set_has_error_msg();
      error_msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.error_msg_);
    }
    if (from.has_display_msg()) {
      set_has_display_msg();
      display_msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.display_msg_);
    }
    if (from.has_max_feed_lin()) {
      set_max_feed_lin(from.max_feed_lin());
    }
    if (from.has_max_feed_ang()) {
      set_max_feed_ang(from.max_feed_ang());
    }
    if (from.has_gcode_units()) {
      set_gcode_units(from.gcode_units());
    }
    if (from.has_spindle_override()) {
      set_spindle_override(from.spindle_override());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_rapid_override()) {
      set_rapid_override(from.rapid_override());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void StateBuf::CopyFrom(const StateBuf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CncRemote.StateBuf)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool StateBuf::IsInitialized() const {

  return true;
}

void StateBuf::Swap(StateBuf* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StateBuf::InternalSwap(StateBuf* other) {
  std::swap(abs_pos_, other->abs_pos_);
  std::swap(offset_work_, other->offset_work_);
  std::swap(offset_fixture_, other->offset_fixture_);
  std::swap(feed_override_, other->feed_override_);
  std::swap(control_on_, other->control_on_);
  std::swap(machine_connected_, other->machine_connected_);
  std::swap(paused_, other->paused_);
  std::swap(optional_stop_, other->optional_stop_);
  std::swap(block_delete_, other->block_delete_);
  std::swap(busy_, other->busy_);
  std::swap(current_line_, other->current_line_);
  std::swap(single_step_, other->single_step_);
  std::swap(spindle_speed_, other->spindle_speed_);
  std::swap(spindle_state_, other->spindle_state_);
  std::swap(mist_, other->mist_);
  std::swap(flood_, other->flood_);
  std::swap(homed_, other->homed_);
  std::swap(axis_linear_, other->axis_linear_);
  error_msg_.Swap(&other->error_msg_);
  display_msg_.Swap(&other->display_msg_);
  std::swap(max_feed_lin_, other->max_feed_lin_);
  std::swap(max_feed_ang_, other->max_feed_ang_);
  std::swap(gcode_units_, other->gcode_units_);
  std::swap(spindle_override_, other->spindle_override_);
  std::swap(rapid_override_, other->rapid_override_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StateBuf::GetTypeName() const {
  return "CncRemote.StateBuf";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StateBuf

// optional .CncRemote.Axes abs_pos = 2;
bool StateBuf::has_abs_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StateBuf::set_has_abs_pos() {
  _has_bits_[0] |= 0x00000001u;
}
void StateBuf::clear_has_abs_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
void StateBuf::clear_abs_pos() {
  if (abs_pos_ != NULL) abs_pos_->::CncRemote::Axes::Clear();
  clear_has_abs_pos();
}
const ::CncRemote::Axes& StateBuf::abs_pos() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.abs_pos)
  return abs_pos_ != NULL ? *abs_pos_
                         : *::CncRemote::Axes::internal_default_instance();
}
::CncRemote::Axes* StateBuf::mutable_abs_pos() {
  set_has_abs_pos();
  if (abs_pos_ == NULL) {
    abs_pos_ = new ::CncRemote::Axes;
  }
  // @@protoc_insertion_point(field_mutable:CncRemote.StateBuf.abs_pos)
  return abs_pos_;
}
::CncRemote::Axes* StateBuf::release_abs_pos() {
  // @@protoc_insertion_point(field_release:CncRemote.StateBuf.abs_pos)
  clear_has_abs_pos();
  ::CncRemote::Axes* temp = abs_pos_;
  abs_pos_ = NULL;
  return temp;
}
void StateBuf::set_allocated_abs_pos(::CncRemote::Axes* abs_pos) {
  delete abs_pos_;
  abs_pos_ = abs_pos;
  if (abs_pos) {
    set_has_abs_pos();
  } else {
    clear_has_abs_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:CncRemote.StateBuf.abs_pos)
}

// optional .CncRemote.Axes offset_work = 3;
bool StateBuf::has_offset_work() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void StateBuf::set_has_offset_work() {
  _has_bits_[0] |= 0x00000002u;
}
void StateBuf::clear_has_offset_work() {
  _has_bits_[0] &= ~0x00000002u;
}
void StateBuf::clear_offset_work() {
  if (offset_work_ != NULL) offset_work_->::CncRemote::Axes::Clear();
  clear_has_offset_work();
}
const ::CncRemote::Axes& StateBuf::offset_work() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.offset_work)
  return offset_work_ != NULL ? *offset_work_
                         : *::CncRemote::Axes::internal_default_instance();
}
::CncRemote::Axes* StateBuf::mutable_offset_work() {
  set_has_offset_work();
  if (offset_work_ == NULL) {
    offset_work_ = new ::CncRemote::Axes;
  }
  // @@protoc_insertion_point(field_mutable:CncRemote.StateBuf.offset_work)
  return offset_work_;
}
::CncRemote::Axes* StateBuf::release_offset_work() {
  // @@protoc_insertion_point(field_release:CncRemote.StateBuf.offset_work)
  clear_has_offset_work();
  ::CncRemote::Axes* temp = offset_work_;
  offset_work_ = NULL;
  return temp;
}
void StateBuf::set_allocated_offset_work(::CncRemote::Axes* offset_work) {
  delete offset_work_;
  offset_work_ = offset_work;
  if (offset_work) {
    set_has_offset_work();
  } else {
    clear_has_offset_work();
  }
  // @@protoc_insertion_point(field_set_allocated:CncRemote.StateBuf.offset_work)
}

// optional .CncRemote.Axes offset_fixture = 4;
bool StateBuf::has_offset_fixture() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void StateBuf::set_has_offset_fixture() {
  _has_bits_[0] |= 0x00000004u;
}
void StateBuf::clear_has_offset_fixture() {
  _has_bits_[0] &= ~0x00000004u;
}
void StateBuf::clear_offset_fixture() {
  if (offset_fixture_ != NULL) offset_fixture_->::CncRemote::Axes::Clear();
  clear_has_offset_fixture();
}
const ::CncRemote::Axes& StateBuf::offset_fixture() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.offset_fixture)
  return offset_fixture_ != NULL ? *offset_fixture_
                         : *::CncRemote::Axes::internal_default_instance();
}
::CncRemote::Axes* StateBuf::mutable_offset_fixture() {
  set_has_offset_fixture();
  if (offset_fixture_ == NULL) {
    offset_fixture_ = new ::CncRemote::Axes;
  }
  // @@protoc_insertion_point(field_mutable:CncRemote.StateBuf.offset_fixture)
  return offset_fixture_;
}
::CncRemote::Axes* StateBuf::release_offset_fixture() {
  // @@protoc_insertion_point(field_release:CncRemote.StateBuf.offset_fixture)
  clear_has_offset_fixture();
  ::CncRemote::Axes* temp = offset_fixture_;
  offset_fixture_ = NULL;
  return temp;
}
void StateBuf::set_allocated_offset_fixture(::CncRemote::Axes* offset_fixture) {
  delete offset_fixture_;
  offset_fixture_ = offset_fixture;
  if (offset_fixture) {
    set_has_offset_fixture();
  } else {
    clear_has_offset_fixture();
  }
  // @@protoc_insertion_point(field_set_allocated:CncRemote.StateBuf.offset_fixture)
}

// optional double feed_override = 6;
bool StateBuf::has_feed_override() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void StateBuf::set_has_feed_override() {
  _has_bits_[0] |= 0x00000008u;
}
void StateBuf::clear_has_feed_override() {
  _has_bits_[0] &= ~0x00000008u;
}
void StateBuf::clear_feed_override() {
  feed_override_ = 0;
  clear_has_feed_override();
}
double StateBuf::feed_override() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.feed_override)
  return feed_override_;
}
void StateBuf::set_feed_override(double value) {
  set_has_feed_override();
  feed_override_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.feed_override)
}

// optional bool control_on = 7;
bool StateBuf::has_control_on() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void StateBuf::set_has_control_on() {
  _has_bits_[0] |= 0x00000010u;
}
void StateBuf::clear_has_control_on() {
  _has_bits_[0] &= ~0x00000010u;
}
void StateBuf::clear_control_on() {
  control_on_ = false;
  clear_has_control_on();
}
bool StateBuf::control_on() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.control_on)
  return control_on_;
}
void StateBuf::set_control_on(bool value) {
  set_has_control_on();
  control_on_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.control_on)
}

// optional bool machine_connected = 8;
bool StateBuf::has_machine_connected() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void StateBuf::set_has_machine_connected() {
  _has_bits_[0] |= 0x00000020u;
}
void StateBuf::clear_has_machine_connected() {
  _has_bits_[0] &= ~0x00000020u;
}
void StateBuf::clear_machine_connected() {
  machine_connected_ = false;
  clear_has_machine_connected();
}
bool StateBuf::machine_connected() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.machine_connected)
  return machine_connected_;
}
void StateBuf::set_machine_connected(bool value) {
  set_has_machine_connected();
  machine_connected_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.machine_connected)
}

// optional bool paused = 9;
bool StateBuf::has_paused() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void StateBuf::set_has_paused() {
  _has_bits_[0] |= 0x00000040u;
}
void StateBuf::clear_has_paused() {
  _has_bits_[0] &= ~0x00000040u;
}
void StateBuf::clear_paused() {
  paused_ = false;
  clear_has_paused();
}
bool StateBuf::paused() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.paused)
  return paused_;
}
void StateBuf::set_paused(bool value) {
  set_has_paused();
  paused_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.paused)
}

// optional bool optional_stop = 10;
bool StateBuf::has_optional_stop() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void StateBuf::set_has_optional_stop() {
  _has_bits_[0] |= 0x00000080u;
}
void StateBuf::clear_has_optional_stop() {
  _has_bits_[0] &= ~0x00000080u;
}
void StateBuf::clear_optional_stop() {
  optional_stop_ = false;
  clear_has_optional_stop();
}
bool StateBuf::optional_stop() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.optional_stop)
  return optional_stop_;
}
void StateBuf::set_optional_stop(bool value) {
  set_has_optional_stop();
  optional_stop_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.optional_stop)
}

// optional bool block_delete = 11;
bool StateBuf::has_block_delete() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void StateBuf::set_has_block_delete() {
  _has_bits_[0] |= 0x00000100u;
}
void StateBuf::clear_has_block_delete() {
  _has_bits_[0] &= ~0x00000100u;
}
void StateBuf::clear_block_delete() {
  block_delete_ = false;
  clear_has_block_delete();
}
bool StateBuf::block_delete() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.block_delete)
  return block_delete_;
}
void StateBuf::set_block_delete(bool value) {
  set_has_block_delete();
  block_delete_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.block_delete)
}

// optional bool busy = 12;
bool StateBuf::has_busy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void StateBuf::set_has_busy() {
  _has_bits_[0] |= 0x00000200u;
}
void StateBuf::clear_has_busy() {
  _has_bits_[0] &= ~0x00000200u;
}
void StateBuf::clear_busy() {
  busy_ = false;
  clear_has_busy();
}
bool StateBuf::busy() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.busy)
  return busy_;
}
void StateBuf::set_busy(bool value) {
  set_has_busy();
  busy_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.busy)
}

// optional int32 current_line = 13;
bool StateBuf::has_current_line() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void StateBuf::set_has_current_line() {
  _has_bits_[0] |= 0x00000400u;
}
void StateBuf::clear_has_current_line() {
  _has_bits_[0] &= ~0x00000400u;
}
void StateBuf::clear_current_line() {
  current_line_ = 0;
  clear_has_current_line();
}
::google::protobuf::int32 StateBuf::current_line() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.current_line)
  return current_line_;
}
void StateBuf::set_current_line(::google::protobuf::int32 value) {
  set_has_current_line();
  current_line_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.current_line)
}

// optional bool single_step = 14;
bool StateBuf::has_single_step() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void StateBuf::set_has_single_step() {
  _has_bits_[0] |= 0x00000800u;
}
void StateBuf::clear_has_single_step() {
  _has_bits_[0] &= ~0x00000800u;
}
void StateBuf::clear_single_step() {
  single_step_ = false;
  clear_has_single_step();
}
bool StateBuf::single_step() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.single_step)
  return single_step_;
}
void StateBuf::set_single_step(bool value) {
  set_has_single_step();
  single_step_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.single_step)
}

// optional double spindle_speed = 15;
bool StateBuf::has_spindle_speed() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void StateBuf::set_has_spindle_speed() {
  _has_bits_[0] |= 0x00001000u;
}
void StateBuf::clear_has_spindle_speed() {
  _has_bits_[0] &= ~0x00001000u;
}
void StateBuf::clear_spindle_speed() {
  spindle_speed_ = 0;
  clear_has_spindle_speed();
}
double StateBuf::spindle_speed() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.spindle_speed)
  return spindle_speed_;
}
void StateBuf::set_spindle_speed(double value) {
  set_has_spindle_speed();
  spindle_speed_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.spindle_speed)
}

// optional uint32 spindle_state = 16;
bool StateBuf::has_spindle_state() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void StateBuf::set_has_spindle_state() {
  _has_bits_[0] |= 0x00002000u;
}
void StateBuf::clear_has_spindle_state() {
  _has_bits_[0] &= ~0x00002000u;
}
void StateBuf::clear_spindle_state() {
  spindle_state_ = 0u;
  clear_has_spindle_state();
}
::google::protobuf::uint32 StateBuf::spindle_state() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.spindle_state)
  return spindle_state_;
}
void StateBuf::set_spindle_state(::google::protobuf::uint32 value) {
  set_has_spindle_state();
  spindle_state_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.spindle_state)
}

// optional bool mist = 17;
bool StateBuf::has_mist() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void StateBuf::set_has_mist() {
  _has_bits_[0] |= 0x00004000u;
}
void StateBuf::clear_has_mist() {
  _has_bits_[0] &= ~0x00004000u;
}
void StateBuf::clear_mist() {
  mist_ = false;
  clear_has_mist();
}
bool StateBuf::mist() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.mist)
  return mist_;
}
void StateBuf::set_mist(bool value) {
  set_has_mist();
  mist_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.mist)
}

// optional bool flood = 18;
bool StateBuf::has_flood() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void StateBuf::set_has_flood() {
  _has_bits_[0] |= 0x00008000u;
}
void StateBuf::clear_has_flood() {
  _has_bits_[0] &= ~0x00008000u;
}
void StateBuf::clear_flood() {
  flood_ = false;
  clear_has_flood();
}
bool StateBuf::flood() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.flood)
  return flood_;
}
void StateBuf::set_flood(bool value) {
  set_has_flood();
  flood_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.flood)
}

// optional .CncRemote.BoolAxes homed = 19;
bool StateBuf::has_homed() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void StateBuf::set_has_homed() {
  _has_bits_[0] |= 0x00010000u;
}
void StateBuf::clear_has_homed() {
  _has_bits_[0] &= ~0x00010000u;
}
void StateBuf::clear_homed() {
  if (homed_ != NULL) homed_->::CncRemote::BoolAxes::Clear();
  clear_has_homed();
}
const ::CncRemote::BoolAxes& StateBuf::homed() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.homed)
  return homed_ != NULL ? *homed_
                         : *::CncRemote::BoolAxes::internal_default_instance();
}
::CncRemote::BoolAxes* StateBuf::mutable_homed() {
  set_has_homed();
  if (homed_ == NULL) {
    homed_ = new ::CncRemote::BoolAxes;
  }
  // @@protoc_insertion_point(field_mutable:CncRemote.StateBuf.homed)
  return homed_;
}
::CncRemote::BoolAxes* StateBuf::release_homed() {
  // @@protoc_insertion_point(field_release:CncRemote.StateBuf.homed)
  clear_has_homed();
  ::CncRemote::BoolAxes* temp = homed_;
  homed_ = NULL;
  return temp;
}
void StateBuf::set_allocated_homed(::CncRemote::BoolAxes* homed) {
  delete homed_;
  homed_ = homed;
  if (homed) {
    set_has_homed();
  } else {
    clear_has_homed();
  }
  // @@protoc_insertion_point(field_set_allocated:CncRemote.StateBuf.homed)
}

// optional .CncRemote.BoolAxes axis_linear = 20;
bool StateBuf::has_axis_linear() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void StateBuf::set_has_axis_linear() {
  _has_bits_[0] |= 0x00020000u;
}
void StateBuf::clear_has_axis_linear() {
  _has_bits_[0] &= ~0x00020000u;
}
void StateBuf::clear_axis_linear() {
  if (axis_linear_ != NULL) axis_linear_->::CncRemote::BoolAxes::Clear();
  clear_has_axis_linear();
}
const ::CncRemote::BoolAxes& StateBuf::axis_linear() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.axis_linear)
  return axis_linear_ != NULL ? *axis_linear_
                         : *::CncRemote::BoolAxes::internal_default_instance();
}
::CncRemote::BoolAxes* StateBuf::mutable_axis_linear() {
  set_has_axis_linear();
  if (axis_linear_ == NULL) {
    axis_linear_ = new ::CncRemote::BoolAxes;
  }
  // @@protoc_insertion_point(field_mutable:CncRemote.StateBuf.axis_linear)
  return axis_linear_;
}
::CncRemote::BoolAxes* StateBuf::release_axis_linear() {
  // @@protoc_insertion_point(field_release:CncRemote.StateBuf.axis_linear)
  clear_has_axis_linear();
  ::CncRemote::BoolAxes* temp = axis_linear_;
  axis_linear_ = NULL;
  return temp;
}
void StateBuf::set_allocated_axis_linear(::CncRemote::BoolAxes* axis_linear) {
  delete axis_linear_;
  axis_linear_ = axis_linear;
  if (axis_linear) {
    set_has_axis_linear();
  } else {
    clear_has_axis_linear();
  }
  // @@protoc_insertion_point(field_set_allocated:CncRemote.StateBuf.axis_linear)
}

// optional string error_msg = 21;
bool StateBuf::has_error_msg() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void StateBuf::set_has_error_msg() {
  _has_bits_[0] |= 0x00040000u;
}
void StateBuf::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00040000u;
}
void StateBuf::clear_error_msg() {
  error_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_msg();
}
const ::std::string& StateBuf::error_msg() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.error_msg)
  return error_msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void StateBuf::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.error_msg)
}
void StateBuf::set_error_msg(const char* value) {
  set_has_error_msg();
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CncRemote.StateBuf.error_msg)
}
void StateBuf::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CncRemote.StateBuf.error_msg)
}
::std::string* StateBuf::mutable_error_msg() {
  set_has_error_msg();
  // @@protoc_insertion_point(field_mutable:CncRemote.StateBuf.error_msg)
  return error_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* StateBuf::release_error_msg() {
  // @@protoc_insertion_point(field_release:CncRemote.StateBuf.error_msg)
  clear_has_error_msg();
  return error_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void StateBuf::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg != NULL) {
    set_has_error_msg();
  } else {
    clear_has_error_msg();
  }
  error_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_msg);
  // @@protoc_insertion_point(field_set_allocated:CncRemote.StateBuf.error_msg)
}

// optional string display_msg = 22;
bool StateBuf::has_display_msg() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void StateBuf::set_has_display_msg() {
  _has_bits_[0] |= 0x00080000u;
}
void StateBuf::clear_has_display_msg() {
  _has_bits_[0] &= ~0x00080000u;
}
void StateBuf::clear_display_msg() {
  display_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_display_msg();
}
const ::std::string& StateBuf::display_msg() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.display_msg)
  return display_msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void StateBuf::set_display_msg(const ::std::string& value) {
  set_has_display_msg();
  display_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.display_msg)
}
void StateBuf::set_display_msg(const char* value) {
  set_has_display_msg();
  display_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CncRemote.StateBuf.display_msg)
}
void StateBuf::set_display_msg(const char* value, size_t size) {
  set_has_display_msg();
  display_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CncRemote.StateBuf.display_msg)
}
::std::string* StateBuf::mutable_display_msg() {
  set_has_display_msg();
  // @@protoc_insertion_point(field_mutable:CncRemote.StateBuf.display_msg)
  return display_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* StateBuf::release_display_msg() {
  // @@protoc_insertion_point(field_release:CncRemote.StateBuf.display_msg)
  clear_has_display_msg();
  return display_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void StateBuf::set_allocated_display_msg(::std::string* display_msg) {
  if (display_msg != NULL) {
    set_has_display_msg();
  } else {
    clear_has_display_msg();
  }
  display_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), display_msg);
  // @@protoc_insertion_point(field_set_allocated:CncRemote.StateBuf.display_msg)
}

// optional double max_feed_lin = 23;
bool StateBuf::has_max_feed_lin() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void StateBuf::set_has_max_feed_lin() {
  _has_bits_[0] |= 0x00100000u;
}
void StateBuf::clear_has_max_feed_lin() {
  _has_bits_[0] &= ~0x00100000u;
}
void StateBuf::clear_max_feed_lin() {
  max_feed_lin_ = 0;
  clear_has_max_feed_lin();
}
double StateBuf::max_feed_lin() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.max_feed_lin)
  return max_feed_lin_;
}
void StateBuf::set_max_feed_lin(double value) {
  set_has_max_feed_lin();
  max_feed_lin_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.max_feed_lin)
}

// optional double max_feed_ang = 24;
bool StateBuf::has_max_feed_ang() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
void StateBuf::set_has_max_feed_ang() {
  _has_bits_[0] |= 0x00200000u;
}
void StateBuf::clear_has_max_feed_ang() {
  _has_bits_[0] &= ~0x00200000u;
}
void StateBuf::clear_max_feed_ang() {
  max_feed_ang_ = 0;
  clear_has_max_feed_ang();
}
double StateBuf::max_feed_ang() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.max_feed_ang)
  return max_feed_ang_;
}
void StateBuf::set_max_feed_ang(double value) {
  set_has_max_feed_ang();
  max_feed_ang_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.max_feed_ang)
}

// optional double gcode_units = 25;
bool StateBuf::has_gcode_units() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
void StateBuf::set_has_gcode_units() {
  _has_bits_[0] |= 0x00400000u;
}
void StateBuf::clear_has_gcode_units() {
  _has_bits_[0] &= ~0x00400000u;
}
void StateBuf::clear_gcode_units() {
  gcode_units_ = 0;
  clear_has_gcode_units();
}
double StateBuf::gcode_units() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.gcode_units)
  return gcode_units_;
}
void StateBuf::set_gcode_units(double value) {
  set_has_gcode_units();
  gcode_units_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.gcode_units)
}

// optional double spindle_override = 26;
bool StateBuf::has_spindle_override() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
void StateBuf::set_has_spindle_override() {
  _has_bits_[0] |= 0x00800000u;
}
void StateBuf::clear_has_spindle_override() {
  _has_bits_[0] &= ~0x00800000u;
}
void StateBuf::clear_spindle_override() {
  spindle_override_ = 0;
  clear_has_spindle_override();
}
double StateBuf::spindle_override() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.spindle_override)
  return spindle_override_;
}
void StateBuf::set_spindle_override(double value) {
  set_has_spindle_override();
  spindle_override_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.spindle_override)
}

// optional double rapid_override = 27;
bool StateBuf::has_rapid_override() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
void StateBuf::set_has_rapid_override() {
  _has_bits_[0] |= 0x01000000u;
}
void StateBuf::clear_has_rapid_override() {
  _has_bits_[0] &= ~0x01000000u;
}
void StateBuf::clear_rapid_override() {
  rapid_override_ = 0;
  clear_has_rapid_override();
}
double StateBuf::rapid_override() const {
  // @@protoc_insertion_point(field_get:CncRemote.StateBuf.rapid_override)
  return rapid_override_;
}
void StateBuf::set_rapid_override(double value) {
  set_has_rapid_override();
  rapid_override_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.StateBuf.rapid_override)
}

inline const StateBuf* StateBuf::internal_default_instance() {
  return &StateBuf_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForCmdBuf(
    CmdBuf* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CmdBuf::kStringFieldNumber;
const int CmdBuf::kStateFieldNumber;
const int CmdBuf::kAxesFieldNumber;
const int CmdBuf::kBoolAxesFieldNumber;
const int CmdBuf::kRateFieldNumber;
const int CmdBuf::kIntvalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CmdBuf::CmdBuf()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_cncstatebuf_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:CncRemote.CmdBuf)
}

void CmdBuf::InitAsDefaultInstance() {
  axes_ = const_cast< ::CncRemote::Axes*>(
      ::CncRemote::Axes::internal_default_instance());
  bool_axes_ = const_cast< ::CncRemote::BoolAxes*>(
      ::CncRemote::BoolAxes::internal_default_instance());
}

CmdBuf::CmdBuf(const CmdBuf& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:CncRemote.CmdBuf)
}

void CmdBuf::SharedCtor() {
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  axes_ = NULL;
  bool_axes_ = NULL;
  ::memset(&state_, 0, reinterpret_cast<char*>(&rate_) -
    reinterpret_cast<char*>(&state_) + sizeof(rate_));
}

CmdBuf::~CmdBuf() {
  // @@protoc_insertion_point(destructor:CncRemote.CmdBuf)
  SharedDtor();
}

void CmdBuf::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  string_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != &CmdBuf_default_instance_.get()) {
    delete axes_;
    delete bool_axes_;
  }
}

void CmdBuf::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CmdBuf& CmdBuf::default_instance() {
  protobuf_InitDefaults_cncstatebuf_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<CmdBuf> CmdBuf_default_instance_;

CmdBuf* CmdBuf::New(::google::protobuf::Arena* arena) const {
  CmdBuf* n = new CmdBuf;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CmdBuf::Clear() {
// @@protoc_insertion_point(message_clear_start:CncRemote.CmdBuf)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(CmdBuf, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CmdBuf*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&(first), 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(state_, rate_);
    if (has_string()) {
      string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_axes()) {
      if (axes_ != NULL) axes_->::CncRemote::Axes::Clear();
    }
    if (has_bool_axes()) {
      if (bool_axes_ != NULL) bool_axes_->::CncRemote::BoolAxes::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  _has_bits_.Clear();
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool CmdBuf::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForCmdBuf, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:CncRemote.CmdBuf)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string string = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_string()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_state;
        break;
      }

      // optional bool state = 3;
      case 3: {
        if (tag == 24) {
         parse_state:
          set_has_state();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &state_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_axes;
        break;
      }

      // optional .CncRemote.Axes axes = 4;
      case 4: {
        if (tag == 34) {
         parse_axes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_axes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_bool_axes;
        break;
      }

      // optional .CncRemote.BoolAxes bool_axes = 5;
      case 5: {
        if (tag == 42) {
         parse_bool_axes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bool_axes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_rate;
        break;
      }

      // optional double rate = 6;
      case 6: {
        if (tag == 49) {
         parse_rate:
          set_has_rate();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &rate_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_intval;
        break;
      }

      // optional int32 intval = 7;
      case 7: {
        if (tag == 56) {
         parse_intval:
          set_has_intval();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &intval_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:CncRemote.CmdBuf)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:CncRemote.CmdBuf)
  return false;
#undef DO_
}

void CmdBuf::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:CncRemote.CmdBuf)
  // optional string string = 2;
  if (has_string()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->string(), output);
  }

  // optional bool state = 3;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->state(), output);
  }

  // optional .CncRemote.Axes axes = 4;
  if (has_axes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->axes_, output);
  }

  // optional .CncRemote.BoolAxes bool_axes = 5;
  if (has_bool_axes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->bool_axes_, output);
  }

  // optional double rate = 6;
  if (has_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->rate(), output);
  }

  // optional int32 intval = 7;
  if (has_intval()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->intval(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:CncRemote.CmdBuf)
}

size_t CmdBuf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CncRemote.CmdBuf)
  size_t total_size = 0;

  if (_has_bits_[0 / 32] & 63u) {
    // optional string string = 2;
    if (has_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->string());
    }

    // optional bool state = 3;
    if (has_state()) {
      total_size += 1 + 1;
    }

    // optional .CncRemote.Axes axes = 4;
    if (has_axes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->axes_);
    }

    // optional .CncRemote.BoolAxes bool_axes = 5;
    if (has_bool_axes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->bool_axes_);
    }

    // optional double rate = 6;
    if (has_rate()) {
      total_size += 1 + 8;
    }

    // optional int32 intval = 7;
    if (has_intval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->intval());
    }

  }
  total_size += unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CmdBuf::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CmdBuf*>(&from));
}

void CmdBuf::MergeFrom(const CmdBuf& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CncRemote.CmdBuf)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void CmdBuf::UnsafeMergeFrom(const CmdBuf& from) {
  GOOGLE_DCHECK(&from != this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_string()) {
      set_has_string();
      string_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.string_);
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_axes()) {
      mutable_axes()->::CncRemote::Axes::MergeFrom(from.axes());
    }
    if (from.has_bool_axes()) {
      mutable_bool_axes()->::CncRemote::BoolAxes::MergeFrom(from.bool_axes());
    }
    if (from.has_rate()) {
      set_rate(from.rate());
    }
    if (from.has_intval()) {
      set_intval(from.intval());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void CmdBuf::CopyFrom(const CmdBuf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CncRemote.CmdBuf)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool CmdBuf::IsInitialized() const {

  return true;
}

void CmdBuf::Swap(CmdBuf* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CmdBuf::InternalSwap(CmdBuf* other) {
  string_.Swap(&other->string_);
  std::swap(state_, other->state_);
  std::swap(axes_, other->axes_);
  std::swap(bool_axes_, other->bool_axes_);
  std::swap(rate_, other->rate_);
  std::swap(intval_, other->intval_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string CmdBuf::GetTypeName() const {
  return "CncRemote.CmdBuf";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CmdBuf

// optional string string = 2;
bool CmdBuf::has_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CmdBuf::set_has_string() {
  _has_bits_[0] |= 0x00000001u;
}
void CmdBuf::clear_has_string() {
  _has_bits_[0] &= ~0x00000001u;
}
void CmdBuf::clear_string() {
  string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_string();
}
const ::std::string& CmdBuf::string() const {
  // @@protoc_insertion_point(field_get:CncRemote.CmdBuf.string)
  return string_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void CmdBuf::set_string(const ::std::string& value) {
  set_has_string();
  string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CncRemote.CmdBuf.string)
}
void CmdBuf::set_string(const char* value) {
  set_has_string();
  string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CncRemote.CmdBuf.string)
}
void CmdBuf::set_string(const char* value, size_t size) {
  set_has_string();
  string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CncRemote.CmdBuf.string)
}
::std::string* CmdBuf::mutable_string() {
  set_has_string();
  // @@protoc_insertion_point(field_mutable:CncRemote.CmdBuf.string)
  return string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* CmdBuf::release_string() {
  // @@protoc_insertion_point(field_release:CncRemote.CmdBuf.string)
  clear_has_string();
  return string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void CmdBuf::set_allocated_string(::std::string* string) {
  if (string != NULL) {
    set_has_string();
  } else {
    clear_has_string();
  }
  string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), string);
  // @@protoc_insertion_point(field_set_allocated:CncRemote.CmdBuf.string)
}

// optional bool state = 3;
bool CmdBuf::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CmdBuf::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
void CmdBuf::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
void CmdBuf::clear_state() {
  state_ = false;
  clear_has_state();
}
bool CmdBuf::state() const {
  // @@protoc_insertion_point(field_get:CncRemote.CmdBuf.state)
  return state_;
}
void CmdBuf::set_state(bool value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.CmdBuf.state)
}

// optional .CncRemote.Axes axes = 4;
bool CmdBuf::has_axes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CmdBuf::set_has_axes() {
  _has_bits_[0] |= 0x00000004u;
}
void CmdBuf::clear_has_axes() {
  _has_bits_[0] &= ~0x00000004u;
}
void CmdBuf::clear_axes() {
  if (axes_ != NULL) axes_->::CncRemote::Axes::Clear();
  clear_has_axes();
}
const ::CncRemote::Axes& CmdBuf::axes() const {
  // @@protoc_insertion_point(field_get:CncRemote.CmdBuf.axes)
  return axes_ != NULL ? *axes_
                         : *::CncRemote::Axes::internal_default_instance();
}
::CncRemote::Axes* CmdBuf::mutable_axes() {
  set_has_axes();
  if (axes_ == NULL) {
    axes_ = new ::CncRemote::Axes;
  }
  // @@protoc_insertion_point(field_mutable:CncRemote.CmdBuf.axes)
  return axes_;
}
::CncRemote::Axes* CmdBuf::release_axes() {
  // @@protoc_insertion_point(field_release:CncRemote.CmdBuf.axes)
  clear_has_axes();
  ::CncRemote::Axes* temp = axes_;
  axes_ = NULL;
  return temp;
}
void CmdBuf::set_allocated_axes(::CncRemote::Axes* axes) {
  delete axes_;
  axes_ = axes;
  if (axes) {
    set_has_axes();
  } else {
    clear_has_axes();
  }
  // @@protoc_insertion_point(field_set_allocated:CncRemote.CmdBuf.axes)
}

// optional .CncRemote.BoolAxes bool_axes = 5;
bool CmdBuf::has_bool_axes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CmdBuf::set_has_bool_axes() {
  _has_bits_[0] |= 0x00000008u;
}
void CmdBuf::clear_has_bool_axes() {
  _has_bits_[0] &= ~0x00000008u;
}
void CmdBuf::clear_bool_axes() {
  if (bool_axes_ != NULL) bool_axes_->::CncRemote::BoolAxes::Clear();
  clear_has_bool_axes();
}
const ::CncRemote::BoolAxes& CmdBuf::bool_axes() const {
  // @@protoc_insertion_point(field_get:CncRemote.CmdBuf.bool_axes)
  return bool_axes_ != NULL ? *bool_axes_
                         : *::CncRemote::BoolAxes::internal_default_instance();
}
::CncRemote::BoolAxes* CmdBuf::mutable_bool_axes() {
  set_has_bool_axes();
  if (bool_axes_ == NULL) {
    bool_axes_ = new ::CncRemote::BoolAxes;
  }
  // @@protoc_insertion_point(field_mutable:CncRemote.CmdBuf.bool_axes)
  return bool_axes_;
}
::CncRemote::BoolAxes* CmdBuf::release_bool_axes() {
  // @@protoc_insertion_point(field_release:CncRemote.CmdBuf.bool_axes)
  clear_has_bool_axes();
  ::CncRemote::BoolAxes* temp = bool_axes_;
  bool_axes_ = NULL;
  return temp;
}
void CmdBuf::set_allocated_bool_axes(::CncRemote::BoolAxes* bool_axes) {
  delete bool_axes_;
  bool_axes_ = bool_axes;
  if (bool_axes) {
    set_has_bool_axes();
  } else {
    clear_has_bool_axes();
  }
  // @@protoc_insertion_point(field_set_allocated:CncRemote.CmdBuf.bool_axes)
}

// optional double rate = 6;
bool CmdBuf::has_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CmdBuf::set_has_rate() {
  _has_bits_[0] |= 0x00000010u;
}
void CmdBuf::clear_has_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
void CmdBuf::clear_rate() {
  rate_ = 0;
  clear_has_rate();
}
double CmdBuf::rate() const {
  // @@protoc_insertion_point(field_get:CncRemote.CmdBuf.rate)
  return rate_;
}
void CmdBuf::set_rate(double value) {
  set_has_rate();
  rate_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.CmdBuf.rate)
}

// optional int32 intval = 7;
bool CmdBuf::has_intval() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void CmdBuf::set_has_intval() {
  _has_bits_[0] |= 0x00000020u;
}
void CmdBuf::clear_has_intval() {
  _has_bits_[0] &= ~0x00000020u;
}
void CmdBuf::clear_intval() {
  intval_ = 0;
  clear_has_intval();
}
::google::protobuf::int32 CmdBuf::intval() const {
  // @@protoc_insertion_point(field_get:CncRemote.CmdBuf.intval)
  return intval_;
}
void CmdBuf::set_intval(::google::protobuf::int32 value) {
  set_has_intval();
  intval_ = value;
  // @@protoc_insertion_point(field_set:CncRemote.CmdBuf.intval)
}

inline const CmdBuf* CmdBuf::internal_default_instance() {
  return &CmdBuf_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace CncRemote

// @@protoc_insertion_point(global_scope)
